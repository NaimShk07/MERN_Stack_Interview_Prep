## Do you have any questions for me

1. What learning or growth opportunities do developers get here?
2. How does the company support developer growth?
3. Can you tell me about the kind of projects the team is currently working on?
4. What are the next steps in the interview process?
5. How do you see this company evolving in the next year?
6. What do you value most in your engineering team?

## 1. How to secure your node js application

### âœ… Environment Variables

- Store secrets (DB URI, JWT keys) in `.env`
- Never hardcode credentials

### âœ… Secure HTTP Headers

- Use `helmet` middleware
- Sets security-related HTTP headers

### âœ… Error Handling

- Never expose full error stack traces to clients
- Log errors securely (e.g., Winston, Sentry)

### âœ… Use **Authentication & Authorization**

- Protect routes using tokens (e.g., JWT).
- Make sure only the right users access the right data.

### âœ… Use HTTPS: Hypertext Transfer Protocol Secure

- Encrypts data in transit â€” protects against data leaks/sniffing.

### âœ… Limit API Requests

- Apply **rate limiting** to prevent abuse or brute-force attacks.

### âœ… Hide Sensitive Info

- Donâ€™t expose passwords, tokens, or error details in responses.

### âœ… Use CORS(Cross-Origin Resource Sharing) properly

- Restrict which domains can access your APIs.

```js
const allowedOrigins = ["https://yourdomain.com", "https://anotherdomain.com"];

const corOption = {
	origin: (origin, callback) => {
		if (!origin) return callback(null, true); // postman
		if (allowedOrigins.includes(origin)) {
			callback(null, true); // Allow the request
		} else {
			callback(new Error("Not allowed by CORS")); // Block the request
		}
	},
	methods: ["GET", "POST", "PATCH"],
};

app.use(cors(corOption));
```

## 2. ðŸ“¦ What is `package.json`?

- Metadata file for a Node.js project
- Defines `name`, `version`, `scripts`, and dependency ranges
- Required for using `npm` or `yarn`

---

## 3. ðŸ” What is `package-lock.json`?

- Auto-generated by `npm`
- Locks exact versions of all dependencies
- Ensures consistent installs across environments

---

### ðŸ” Why it matters:

- Prevents version-related bugs
- Speeds up installs with resolved dependencies

---

## 4. ðŸ“¦ `package.json` vs ðŸ” `package-lock.json`

### `package.json`

- Edited manually
- Declares needed packages (with version ranges like `^1.0.0`)

### `package-lock.json`

- Created automatically by `npm`
- Records exact versions for reproducible installs

---

## 5. ðŸ—‘ï¸ What if you delete them?

- Delete `package-lock.json` â†’ âœ… App still works, but versions may vary
- Delete `package.json` â†’ âŒ App wonâ€™t work; `npm` canâ€™t install dependencies
- Delete both â†’ âŒ App breaks unless `node_modules` is present

---

## 6. ðŸ—‘ï¸ What if you delete `node_modules`?

- App wonâ€™t run â€” required packages are missing
- Can restore with `npm install` (reads from `package.json` & `package-lock.json`)

---

## 7. ðŸŒ Can we use `http` without `node_modules`?

- âœ… Yes â€” `http` is a **core** Node.js module
- Core modules are built into Node.js (no need to install)

## 8 ðŸ“¦ Reference vs Value | Shallow vs Deep Copy in JavaScript

### ðŸ”¹ Primitive Types â†’ Stored by **Value**

> Copying creates a new value. Changes donâ€™t affect the original.

```js
const a = "Hello";
const b = a;

b = "World";
console.log(a); // "Hello"
```

### ðŸ”¸ Non-Primitives (Objects, Arrays) â†’ Stored by Reference

> Copying just points to the same memory. Changes affect both.

```js
const obj1 = { name: "Alice" };
const obj2 = obj1;

obj2.name = "Bob";
console.log(obj1.name); // "Bob"
```

### ðŸ” Shallow Copy

> Only top-level properties are copied. Nested objects are still shared.

```js
const obj1 = { name: "Alice", address: { city: "NY" } };
const obj2 = { ...obj1 }; // Shallow copy

obj2.name = "Bob"; // âœ… ok
obj2.address.city = "LA"; // âŒ affects obj1

console.log(obj1.address.name); // "Alice"
console.log(obj1.address.city); // "LA"
```

### ðŸ§¬ Deep Copy

> Fully independent copy (including nested objects)

```js
// âœ… Method 1: JSON trick (simple objects only)
const obj2 = JSON.parse(JSON.stringify(obj1));

// âœ… Method 2: structuredClone (modern, safe)
const obj2 = structuredClone(obj1);
```

---

## 9. What is lazy loading

- Loading parts of an app **only when needed**, instead of all at once.

  - Improves initial load time.
  - Saves bandwidth by loading resources on demand.
  - Commonly used for images, components, or modules.

  ```js
  import { lazy, Suspense } from "react";

  const MyComponent = lazy(() => import("./MyComponent"));

  function App() {
  	return (
  		<>
  			<Suspense fallback={<div>Loading...</div>}>
  				<MyComponent />
  			</Suspense>
  		</>
  	);
  }
  ```

---

## 10. What is code spliting

- Code splitting means **breaking your appâ€™s bundle into smaller chunks**.
  - Loads only the necessary code for the current page or feature.
  - Reduces initial load time and improves performance.
  - Often used with tools like Webpack or React.lazy.
  - same like above with out suspence

## 11. What is `this` in JavaScript?

- `this` refers to the **context** in which a function is called
- Depends on **how** the function is invoked
- Arrow functions inherit `this` from their **lexical scope**

### ðŸ“Œ Common `this` behaviors

| Context           | `this` refers to      |
| ----------------- | --------------------- |
| Global (browser)  | `window`              |
| Function (strict) | `undefined`           |
| Object method     | That object           |
| Arrow function    | Lexical (from parent) |
| Class constructor | The new instance      |

```js
const obj = {
	name: "JS",
	arrowFn: () => console.log(this), // âŒ not obj
	normalFn() {
		console.log(this);
	}, // âœ… obj
};
```

---

## 11.1 ðŸŒ `this` in Node.js

- In Node.js, `this` behaves differently than in browsers

| Context               | `this` refers to       |
| --------------------- | ---------------------- |
| Global scope          | `{}` (not `global`)    |
| Function (non-strict) | `global`               |
| Arrow function        | Lexical (like browser) |
| Class method          | Class instance         |

```js
console.log(this); // {} in Node.js

function test() {
	console.log(this); // global
}
test();
```

---

## 11.2 ðŸ”§ `call`, `apply`, `bind`

- `call` â€“ calls function with `this` and args individually
- `apply` â€“ calls function with `this` and args as array
- `bind` â€“ returns a new function with `this` bound

```js
function greet(msg, punc) {
	console.log(msg + ", " + this.name + punc);
}
const user = { name: "Alice" };

greet.call(user, "Hello", "!"); // Hello, Alice!
greet.apply(user, ["Hi", "!!"]); // Hi, Alice!!
const fn = greet.bind(user, "Hey", "?");
fn(); // Hey, Alice?
```

---

## 12. `console.log(this)` in Browser vs Node.js

### ðŸŒ In Browser (global scope)

```js
console.log(this); // window
```

- Global `this` points to `window`

### ðŸ–¥ï¸ In Node.js (global scope)

```js
console.log(this); // {}
```

- Global `this` is `{}` due to module wrapper

### ðŸ§  Why?

- Browser: `this === window`
- Node: `this === module.exports` at top-level

```js
// Browser
console.log(this === window); // true

// Node.js
console.log(this === global); // false
```

## 13. Difference between `express.json()` and `express.urlencoded()`

Used in Express.js to parse incoming request bodies before your handlers.

### ðŸ“Œ `express.json()`

- Parses incoming requests with `JSON` payloads
- Used for `application/json` content type

```js
app.use(express.json());
```

---

### ðŸ“Œ `express.urlencoded({ extended: true })`

- Parses incoming requests with `URL-encoded` payloads (like from HTML forms)
- `extended: true` allows rich objects and arrays (uses `qs` library instead of `querystring`)

```js
app.use(express.urlencoded({ extended: true }));
```

---

### âœ… Key Points

- `express.json()` â†’ for APIs sending JSON
- `express.urlencoded()` â†’ for form data (`application/x-www-form-urlencoded`)
- You can use both if your app handles both types of data
- `extended: true` handles nested objects: `{ user: { name: "Tom" } }`

## 14. how to handle one to many relationship in mongodb

- A single document is related to multiple documents.

  - `Embedded`: When the "many" documents are few and tightly coupled.

  ```js
   { name: "User", posts: [ { title: "Post1" }, { title: "Post2" } ] }
  ```

  - `Referenced`: When the "many" documents are many, large, or independent.

  ```js
   // UserD
   { _id: 1, name: "User" }
   // Posts
   { title: "Post1", user_id: 1 }
  ```

---

## 15. ðŸŒ What happens when you type a URL and hit Enter?

- When I hit enter after typing a URL, the browser does a DNS lookup to find the IP, establishes a TCP connection, does a TLS handshake if it's HTTPS, sends an HTTP request, and then starts rendering the response â€” parsing HTML, applying CSS, running JS â€” until the full page loads.

### ðŸ§­ Step-by-step Breakdown:

1. **DNS Lookup**

   - URL â†’ IP address using DNS.

2. **TCP Connection**

   - Browser establishes a **TCP handshake** (via port 80/443).

3. **HTTP Request Sent**

   - Browser sends a **GET** request for the web page.

4. **Server Response**

   - Server sends back HTML, CSS, JS, images, etc.

5. **Browser Rendering**

   - HTML parsed â†’ DOM created
   - CSS applied â†’ Render Tree
   - JS executed â†’ Dynamic content loaded

6. **Page Loaded & Displayed**

---

```mermaid
graph TD
URL --> DNS_Lookup --> TCP_Connection --> TLS_Handshake --> HTTP_Request --> Server_Response --> Browser_Rendering --> Page_Ready
```
